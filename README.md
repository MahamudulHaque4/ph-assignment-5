What is the difference between getElementById, getElementsByClassName, and querySelector / querySelectorAll? Ans:The main difference is how they choose elements and what they give back. getElementById is the most specific and fastest way to get an element by its unique id and return an element object. getElementsByClassName gets a live HTMLCollection of all elements with a certain class. This means that it updates automatically when the DOM changes. In contrast, querySelector and querySelectorAll are newer and more flexible. They use CSS selectors to find elements. querySelector returns the first matching element, while querySelectorAll returns a static NodeList of all matching elements. This is a snapshot that doesn't change, so it's easier to work with.
How do you create and insert a new element into the DOM? Ans: A new element must first be created using a document in order to be inserted into the DOM. give the tag name (such as "div" or "p") to createElement(). This new element is not yet visible on the page; it only exists in memory. Next, you can modify its textContent or use methods like setAttribute() to set its attributes or content. Lastly, you use a method like parentElement to append it to an existing parent element on the page. appendChild(). This approach adds the new element to the visible document structure by placing it as the last child of the designated parent.
What is Event Bubbling and how does it work? Ans:The process by which an event that is triggered on an element moves up through its ancestors in the DOM tree, from the deepest element to the root, is known as event bubbling. The button's event listener handles the event when a user clicks a nested element, such as a button inside a div. It then "bubbles up" to the parent div, which is triggered next if it has an event listener for the same kind of event. The body, html, and window objects are further up the hierarchy. Event.stopPropagation() can be used to halt this behavior at any time, but it is essential for event delegation because it enables a single event listener on a parent element to manage events for all of its children.
What is Event Delegation in JavaScript? Why is it useful? Ans:Event delegation is a design pattern in JavaScript where a single event listener is attached to a parent element. This listener manages events for all of its child elements. Instead of adding a separate listener to each child, the parent's listener listens for events that bubble up from the children. When an event occurs on a child, the parent's event listener catches it. You can use the ""event.target"" property to find out which specific child element triggered the event. This method is useful because it improves performance by lowering the number of event listeners attached to the DOM, which saves memory. It also makes the code more efficient and easy to maintain since it can handle child elements that are added or removed without needing to change the listeners for each one.
What is the difference between preventDefault() and stopPropagation() methods? Ans:The key difference between `preventDefault()`and`stopPropagation()` is what they prevent. **`preventDefault()`** prevents the default action of an event. For example, it can be used to prevent a form from submitting when a submit button is clicked, or prevent a link from navigating another page when clicked. In contrast, **`stopPropagation()`** prevents the event from propagating or "bubbling up" the DOM tree to parent nodes. It's used to ensure that an event will not be processed by any of the ancestor elements it was triggered on, and not cause any ancestor elements with event listeners to fire. Essentially, `preventDefault()`handles the **default behavior of the event**, while`stopPropagation()` handles the **event path through the DOM**.
